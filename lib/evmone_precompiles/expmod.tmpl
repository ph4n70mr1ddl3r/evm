{{- $exponent := "" -}}
{{- range $exponent = $.Chain }}{{ end -}}

uint256 expmod_(const ModArith<uint256>& m, const uint256& x) noexcept
{
    // Computes modular exponentiation
    // x^{{ printf "%#x" $exponent }}
    // Operations: {{ .Ops.Doubles }} squares {{ .Ops.Adds }} multiplies
    // Generated by {{ .Meta.Module }} {{ .Meta.ReleaseTag }}.
    //
    // Exponentiation computation is derived from the addition chain:
    //
    {{- range lines (format .Script) }}
    // {{ . }}
    {{- end }}

    // Allocate Temporaries.
    uint256 z;
    {{- range .Program.Temporaries }}
    uint256 {{ . }};
    {{- end }}

    {{ range $i := .Program.Instructions }}
    // {{ printf "Step %d: %s = x^%#x" $i.Output.Index $i.Output (index $.Chain $i.Output.Index) }}
    {{- with add $i.Op }}
    {{ $i.Output }} = m.mul({{ .X }}, {{ .Y }});
    {{ end -}}

    {{- with double $i.Op }}
    {{ $i.Output }} = m.mul({{ .X }}, {{ .X }});
    {{ end -}}

    {{- with shift $i.Op -}}
    {{- $first := 0 -}}
    {{- if ne $i.Output.Identifier .X.Identifier }}
    {{ $i.Output }} = m.mul({{ .X }}, {{ .X }});
    {{- $first = 1 -}}
    {{- end }}
    for (int i = {{ $first }}; i < {{ .S }}; ++i)
        {{ $i.Output }} = m.mul({{ $i.Output }}, {{ $i.Output }});
    {{ end -}}
    {{- end }}
    return z;
}
